# 요구사항 확인
## 01. 소프트웨어 생명 주기
-------------------
### 소프트웨어 생명 주기
 - 소프트웨어를 개발하기 위해 정의하고 운영, 유지보수 등의 과정을 각 단계별로 나눈 것.   
 - 개발자는 문제의 유형이나 개발 방법 등에 따라 특정 모형을 선택하여 사용하거나 개별적인 모형 사용할 수 있음.
 -  ex. 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등

### 소프트웨어 공학
 - 소프트웨어의 위기 극복 방안으로 연구된 학문, 소프트웨어의 품질과 생산성을 향상시킬 목적.
 - 소프트웨어 공학의 기본 원칙
   - 현대적인 프로그래밍 기술을 계속적으로 적용 
   - 새발된 소프트웨어의 품질이 유지되도록 지속적으로 검증 
   - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지

### 폭포수 모형
 - 타탕성 검토 > 계획 > 요구 분석 > 설계 > 구현(코딩) > 시험(검사) > 유지보수
 - 선형 순차적 모델
 - 각 단계를 확실히 매듭 짓고 그 결과를 철저하게 검토한 후 다음 단계를 진행하는 개발 방법론
 - 고전적 생명 주기 모형
 - 성공 사례가 많음
 - 매뉴얼을 작성해야 함
 - 각 단계마다 다음 단계를 수행하기 위한 결과물이 명확히 산출되어야 함
 - 두 개 이상의 과정이 병행되어 수행되지 않음

### 프로토타입 모형
 -  요구수집 > 빠른 설계 > 프로토타입 구축 > 고객 평가 > 프로토타입 조정 > 구현 (반복)
 -  원형 모델
 -  사용자의 요구사항을 정확하게 파악하기 위해 실제 개발될 소프트웨어의 견본품(프로토타입)을 만들어 최종 결과물을 예측하는 모형
 -  사용자와 시스템 사이의 인터페이스에 중점을 두어 개발
 -  개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모델

### 나선형 모형
 - 계획 > 분석 > 개발 > 평가
 - 보헴(Boehm)이 제안, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 것
 - 나선형 모델, 점진적 모형
 - 소프트웨어 개발에서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 함
 - 점진적으로 개발 과정이 반복 > 누락되거나 추가된 요구사항 첨가 가능 > 유지보수 과정이 필요 없음

### 애자일 모형
 - 민첩한, 기민한 이라는 뜻
 - 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행
 - 특정한 개발 방법론이 아닌, 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭
 - 기업활동 전반에 걸쳐 사용
 - 스프린트(sprint), 이터레이션(iteration)이라 불리는 짧은 개발 주기 반복 > 각 주기마다 만들어지는 결과물에 고객의 평가와 요구 적극 수용
 - 소규모 프로젝트, 숙련된 개발자, 급변하는 요구사항에 적합
 - ex. 스크럼, XP, 칸반, Lean, 크리스탈, ASD, 기능 중심 개발, DSDM, DAD 등

### 애자일 선언
 - 2001년 17명의 애자일 전문 개발자가 선언문 작성, 4가지 핵심가치, 12가지 실행 지침
 - 애자일 개발 4가지 핵심 가치
   - 프로세스와 도구보다 개인과 상호작용에 더 가치를 둔다
   - 방대한 문서보다는 실행되는 SW에 더 가치를 둔다
   - 계약 협상보다는 고객과 협업에 더 가치를 둔다
   - 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다

### 폭포수 모형 vs 애자일 모형
|구분|폭포수 모형|애자일 모형|
|---|---|---|
|새로운 요구사항 반영|어려움|지속적으로 반영|
|고객과의 의사소통|적음|지속적임|
|테스트|마지막에 모든 기능을 테스트|반복되는 일정주기가 끝날 때마다 테스트|
|개발 중심|계획, 문서(매뉴얼)|고객|

<br>
<br>
<br>

## 스크럼(Scrum) 기법
-----------------
### 스크럼의 개요
 - 팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어
 - 팀원 스스로가 스크럼 팀을 구성, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 함
 - 팀의 구조
   - 제품 책임자
     - 리더
     - 개발될 제품에 대한 이해도가 높고 요구사항을 책임짐, 주로 개발 의뢰자나 사용자가 담당
     - 백로그 작성 및 우선순위 작성(팀원들은 백로그 우선순위 지정 X)
     - 제품 테스트 진행하면서 주기적으로 요구사항의 우선순위 갱신
   - 스크럼 마스터
     - 객관적 시각에서 조언해주는 가이드 역할 수행
   - 개발팀
     - 개발자 외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람이 대상이 됨
  
### 스크럼 개발 프로세스
 - 제품 백로그 > 스프린트 계획 회의 > 스프린트 > 일일 스크럼 회의 > 스프린트 검토 회의 > 스프린트 회고
 - 제품 백로그
   - 요구사항을 우선순위에 따라 나열한 목록
   - 지속적인 업데이트
   - 제품 백로그에 작성된 사용자 스토리를 기반으로 릴리즈 계획(전체 일정 계획) 수립
 - 스프린트 계획 회의
   - 요구사항을 Task라는 작업 단위로 분할 후 개발자별로 수행할 작업 목록인 스프린트 백로그 작성
 - 스프린트
   - 2 ~ 4주
   - 속도 추정 후 개발 담당자에게 할당
   - 개발자가 원하는 태스크 직접 선별하여 담당할 수 있게 하는 것이 좋음
   - 할 일, 진행중, 완료 상태를 가짐
 - 일일 스크럼 회의
   - 매일 약 15분
   - 소멸 차트(burn-down chart)에 남은 작업 시간 표기
 - 스프린트 검토 회의
   - 주 당 1시간 이내
   - 사용자 포함된 참석자 앞에서 테스트 진행
 - 스프린트 회고
   - 되돌아 보는 회의
   - 스프린트 끝난 시점 or 일정 주기로 수행

<br>
<br>
<br>

## XP(eXtreme Programming) 기법
-----------------
### XP(eXtreme Programming)
 - 고객의 참여와 개발 과정 반복을 극대화 > 개발 생산성 향상
 - 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여
 - 릴리즈의 기간을 짧게 반복 > 요구사항 반영 가시성 높임
 - 릴리즈 테스트마다 고객을 직접 참여
 - 소규모 인원의 개발 프로젝트에 효과적
 - XP의 5대 핵심 가치
   - 의사소통
   - 단순성
   - 용기
   - 존중
   - 피드백

### XP 개발 프로세스
 - 사용자 스토리 > 릴리즈 계획 수립 > 스파이크 > 주기(Iteration) > 승인 검사 > 소규모 릴리즈
 - 사용자 스토리
   - 고객의 요구사항을 간단한 시나리오로 표현한 것
   - 기능 단위로 구성, 필요하다면 간단한 테스트 사항도 기재
 - 릴리즈 계획 수립
   - 일정 수립
 - 스파이크
   - 소프트웨어의 신뢰성과 위험 감소를 위한 별도의 프로그램
   - 처리할 문제 외의 다른 조건은 무시하고 작성됨
 - 이터레이션
   - 릴리즈를 더욱 세분화한 단위
   - 1 ~ 3주
   - 이 기간 중 작성된 새로운 스토리는 진행 중인 이터레이션 or 다음 이터레이션에 포함
 - 승인 검사
   - 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트
   - 고객이 직접 수행
   - 오류 발견 시 다음 이터레이션에 포함
   - 테스트 이후 새로운 요구사항이나 요구사항의 우선 순위 변경 가능
   - 테스트 완료 후 다음 이터레이션 진행
 - 소규모 릴리즈
   - 릴리즈를 소규모로 하게 되면 고객의 반응을 기능별로 확인 가능 > 유연한 대응 가능
  
### XP의 주요 실천 방법
 - Pair Programming(짝 프로그래밍) : 개발에 대한 책임을 공동으로 나누어 가짐
 - Collective Ownership(공동 코드 소유) : 개발 코드에 관한 권한과 책임 공동 소유
 - Test-Driven Development(테스트 주도 개발) : 테스트 케이스를 통해 개발자의 방향성 정확하게 파악, 자동화된 테스팅 도구 사용
 - Whole Team(전체 팀) : 개발에 참여하는 모든 구성원(고객포함)들은 자신의 역할이 있고 그 역할에 책임을 가져야 함
 - Continuous Integration(계속적인 통합) : 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합됨
 - Design Improvement(디자인 개선) / Refactoring(리팩토링) : 프로그램 기능 변경 없이 단순화, 유연성 강화 등을 통해 시스템을 재구성함
 - Small Release(소규모 릴리즈) : 릴리즈 기간을 짧게 반복 > 요구변화에 신속한 대응

<br>
<br>
<br>

## 현행 시스템 파악
-----------------
### 현행 시스템 파악 절차
 - 새로 개발하는 시스템의 개발 범위를 명확하게 설정하기 위한 절차
 - 현생 시스템의 구성, 기능, 시스템 간의 전달 정보, 사용되는 기술 요소, 소프트웨어, 하드웨어, 네트워크 구성 등을 알아야 함
 1. 1단계
    1. 시스템 구성 파악
        - 기간 업무(조직의 주요 업무)와 지원 업무로 나뉨
    2. 시스템 기능 파악
        - 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시
    3. 시스템 인터페이스 파악
        - 시스템 간에 주고 받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시
        - 어떤 형식(XML, 고정포맷, 가변포맷)인지, 통신규약(TCP/IP, X25)은 무엇을 사용하는지, 연계 유형(EAI,FEP)은 무엇인지 등
 2. 2단계
    1. 아키텍쳐 구성 파악
        - 시스템 아키텍쳐 : 시스템 내부에서 각 하위 시스템들이 어떠한 관계로 상호작용하는지 파악할 수 있도록 구성이나 동작 원리를 표현한 것
        - 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성
    2. 소프트웨어 구성 파악
        - 소프트웨어의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 등을 명시
        - 소프트웨어 비용이 적지 않은 비중을 차지하므로 상용 소프트웨어의 경우 라이선스 적용 방식의 기준과 보유한 라이선스의 파악이 중요
 3. 3단계
    1. 하드웨어 구성 파악
        - 서버의 주요 사양(CPU, 메모리, 하드디스크 용량 등), 수량, 이중화의 적용 여부
        - 이중화 : 예비 서버에 동일하게 복제되어 관리되는 것
    2. 네트워크 구성 파악
        - 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 너버 간의 네트워크 연결 방식을 네트워크 구성도로 작성

<br>
<br>
<br>

## 개발 기술 환경 파악
-----------------
### 개발 기술 환경의 정의
 - 운영체제, 데이터베이스 관리 시스템, 미들웨어, 오픈소스 등
 - 미들웨어 : 운영체제와 응용프로그램 사이에서 운영체제가 제공하는 서비스 이외의 추가적인 서비스를 제공하는 소프트웨어
  
### 운영체제(OS, Operating System)
 - 컴퓨터 시스템의 자원을 효율적으로 관리
 - 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있는 환경 제공
 - ex. Windows, UNIX, Linux, Mac OS, Android, iOS 등
 - 운영체제 관련 요구사항 식별 시 고려사항
   - 가용성 : 주어진 시점에서 요구사항에 따라 운영될 수 있는 능력
   - 성능 : 최대 처리량
   - 기술지원
   - 주변기기 : 하드웨어 및 주변기기 지원 여부
   - 구축 비용 : 지원 가능한 하드웨어 비용, 라이선스 비용, 유지 관리 비용, 총 소유 비용(TCO : 어떤 자산을 소유할 때 지정된 기간동안 발생할 수 있는 모든 직,간접 비용)
  
### 데이터베이스 관리 시스템(DBMS)
 - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리해주는 소프트웨어
 - 기존 파일 시스템의 종속성, 중복성 문제 해결을 위해 제안된 시스템, 모든 응용 프로그램이 데이터베이스를 공용할 수 있도록 관리해줌
 - 데이터베이스의 구성, 접근 방법, 유지관리에 대한 모든 책임을 가짐
 - ex. Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQLite, MongoDB 등
 - DBMS 관련 요구사항 식별 시 고려사항
   - 가용성 : 운영 능력
   - 성능 : 처리 능력
   - 기술지원
   - 상호 호환성 : 설치 가능한 운영체제 종류, / JDBC, ODBC와의 호환 여부(JDBC : Java DB, ODBC : Open DB)
   - 구축 비용
  
### 웹 애플리케이션 서버(WAS : Web Application Server)
 - 사용자의 요구에 따라 변하는 동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어(정적인 콘텐츠 처리를 위한 웹 서버와 반대)
 - 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
 - 주로 데이터베이스와 연동해서 사용
 - ex. Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등
 - 웹 애플리케이션 서버 관련 요구사항 식별 시 고려사항
   - 가용성
   - 성능
   - 기술지원
   - 구축비용

### 오픈 소스 사용에 따른 고려사항
 - 오픈 소스 : 누구나 별 다른 제한 없이 사용할 수 있는 소스코드
 - 라이선스의 종류, 사용자 수, 기술의 지속 가능성 등을 고려해야 함

<br>
<br>
<br>

## 요구사항 정의
-----------------
### 요구사항의 개념 및 정의
 - 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약 조건 등을 나타냄
 - 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공
 - 개발하려는 소프트웨어의 전반적인 내용 확인 가능 > 개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 하는 데 도움을 줌
 - 요구사항이 제대로 정의되지 않으면 이후 과정의 목표와 계획을 수립하기 어려움

### 요구사항의 유형
 - 기술하는 내용에 따라
   - 기능 요구사항 : 수행 기능
   - 비기능 요구사항 : 장비, 성능, 인터페이스, 보안, 제약사항 등 
 - 기술 관점과 대상의 범위에 따라
   - 시스템 요구사항 : 개발자 관점
   - 사용자 요구사항 : 사용자 관점

### 요구공학
 - 무엇을 개발해야 하는지 요구사항을 정의하고 분석 및 관리하는 프로세스를 연구하는 학문
 - 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 함
 - 
### 요구사항 개발 프로세스
 - 도출 > 분석 > 명세 > 확인
 - 요구사항 도출(Requirement Elicitation, 요구사항 수집)
   - 이해관계자 간의 의견 교환을 통해 요구사항이 어디에 있는지, 어떻게 수집할 것인지 식별하고 이해하는 과정
   - 소프트웨어 개발 생명 주기동안 지속적으로 반복
   - 청취, 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등
 - 요구사항 분석(Requirement Analysis)
   - 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 걸러내는 과정
   - 요구사항의 타당성 조사, 비용과 일정에 대한 제약 설정
   - 상충되는 요구사항 중재
   - 자료 흐름도(DFD), 자료사전(DD)
 - 요구사항 명세(Requirement Specification)
   - 분석된 요구사항을 바탕으로 모델을 작성하고 문서화 하는 과정
   - 기능 요구사항은 빠짐없이 작성, 비기능 요구사항은 필요한 것만 작성
   - 사용자가 이해하기 쉽고 개발자가 효과적으로 설계할 수 있도록 작성
   - 설계 과정에서 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의서에서 추적할 수 있어야 함
   - 구체적인 명세를 위해 소단위 명세서(Mini-spec)가 사용될 수 있음
   - 요구사항 명세 기법
     - 정형 명세 기법
       - 수학적 원리, 모델 기반
       - 수학적 기호, 정형화된 표기법
       - 명확하고 간결한 표현
       - 작성자와 관계없이 일관성이 있음
       - 표기법이 어려워 사용자가 이해하기 어려움
       - VDM, Z, Petri-net, CSP 등
     - 비정형 명세 기법
       - 상태/기능/객체 중심
       - 일반 명사, 동사 등 자연어 기반으로 서술 or 다이어그램 작성
       - 일관성이 떨어지고 해석이 달라질 수 있음
       - 내용 이해가 쉬워서 의사소통이 용이함
       - FSM, Decision Table, ER모델링, State Chart(SADT) 등
  - 요구사항 확인(Requirement Validation, 요구사항 검증)
    - 개발 자원을 할당하기 전에 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동
    - 분석가가 요구사항을 명확하게 이해하고 작성했는지 확인(Validation)하는 과정
    - 요구사항이 실제 요구를 반영했는지, 상충되는 요구사항 등은 없는지 점검
    - 개발이 완료된 후 문제가 발견되면 재작업 비용이 발생하므로 요구사항 검증은 매우 중요
    - 이해하기 쉬운지, 일관성이 있는지, 회사의 기준에 맞는지, 누락된 기능은 없는지 등
    - 검증 과정을 통해 모든 문제를 확인할 수는 없다
    - 일반적으로 요구사항 관리 도구를 이용하여 요구사항 정의 문서들에 대해 형상관리를 수행
      - 형상관리(SCM, Software Configuration Management) : 소프트웨어 개발 과정에서 만들어지는 형상들의 변경 사항을 관리하는 일련의 활동

<br>
<br>
<br>

## 요구사항 분석
-----------------
### 요구사항 분석의 개요
 - 소프트웨어 개발의 실제적인 첫 단계
 - 사용자의 요구사항을 이해하고 문서화(명세화)하는 활동
 - 타당성 조사와 비용과 일정에 대한 제약 설정
 - 요구사항을 기반으로 목표를 정하고 해결 방안 모색
 - 요구사항 분석을 통한 결과는 정확하고 일관성있게 분석하여 문서화해야함
 - 분석가(전문가)에 의해 요구사항 분석이 수행되며 이 작업 단계를 "요구사항 분석 단계" 라고 함
 - UML, 자료흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-spec), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등의 도구 사용

### 구조적 분석 기법
 - 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 기법
 - 도형 중심의 분석용 도구와 분석 절차 사용
 - 도형 중심의 도구 사용으로 분석가(전문가)와 사용자 간의 대화 용이
 - 하향식 방법(전체적인 수준에서 상세 수준까지 위에서 아래로 단계별로)을 사용하여 시스템을 세분화할 수 있고, 분석의 중복 배제 가능
 - 논리적 표현 기법으로, 전체 시스템을 일관성 있게 이해 가능
 - 시스템 분석의 질이 향상되고, 시스템 개발의 모든 단계에서 필요한 명세서 작성이 가능

### 자료 흐름도(DFD, Data Flow Diagram, 자료 흐름 그래프, 버블 차트)
 - 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
 - 프로세스와 자료 저장소 사이에 자료의 흐름을 나타내는 그래프
 - 자료는 처리(프로세스)를 거쳐 변환될 때마다 새로운 이름이 부여되며, 처리는 입력자료가 발생하면 기능을 수행한 수 출력 자료를 산출
 - 프로세스(process), 자료 흐름(data flow), 자료 저장소(data store), 단말(terminator, 시스템과 교신하는 외부 개체)의 네 가지 기본 기호로 표시
 - 표기법
   - Yourdon/DeMacro
     - 프로세스 : 동그라미 안에 프로세스 이름 기입
     - 자료 흐름 : 화살표 위에 흐르는 자료 이름 기입
     - 자료 저장소 : 위 아래에 줄 그어진 열린 네모 안에 저장소 이름 기입
     - 단말 : 네모 안에 이름 기입
   - Gane/Sarson
     - 프로세스 : 네모 안에 프로세스 이름 기입
     - 자료 흐름 : 화살표 위에 흐르는 자료 이름 기입
     - 자료 저장소 : 닫힌 네모 오른쪽에 열린 네모에 이름 기입
     - 단말 : 겹쳐진 네모 안에 이름 기입

### 자료 사전(DD, Data Dictionary)
 - 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것
 - 데이터의 데이터 혹은 메타 데이터 : 데이터를 설명하는 데이터
 - 표기 기호
   - '=' : 자로의 정의(~로 구성되어 있다)
   - '+' : 자료의 연결(그리고)
   - '( )' : 자료의 생략
   - ' | ' : 자료의 선택(또는, or)
   - '{ }' : 자료의 반복(오른쪽의 주석 n이 아래 : n번 이상 반복 / 오른쪽 위 : 최대 n번 반복 / 아래 m 위 n : m번 이상 n번 이하로 반복)
   - '* *' : 자료의 설명(주석)

<br>
<br>
<br>

## 요구사항 분석 CASE와 HIPO
-----------------
### 요구사항 분석을 위한 CASE(자동화 도구)
 - 요구사항을 자동으로 분석하고 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미
 - 자동화 도구 사용의 이점
   - 표준화된 보고 > 문서화 품질 개선
   - 분석자들 간의 적절한 조정
   - 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이
   - 변경이 주는 영향 추적 용이
   - 명세에 대한 유지보수 비용의 축소
 - 종류 : SADT, SREM, PSL/PSA, TAGS, EPOS 등
 - SADT(Structured Analysis and Design Technique)
   - SoftTech사에서 개발
   - 널리 이용되어 온 구조적 분석 및 설계도구
   - 블록 다이어그램을 채택한 자동화 도구
 - SREM(Software Requirement Engineering Methodology) = RSL/REVS
   - TRW사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확하게 기술하도록 할 목적으로 개발한 것, RSL과 REVS를 사용하는 자동화 도구
   - RSL(Requirement Statement Language) : 요소, 속성, 관계 구조들을 기술하는 요구사항 기술 언어
     - 요소 : 요구사항 명세를 개발하기 위해 사용되는 개채와 개념
     - 속성 : 요소를 수정, 수식하기 위한 것
     - 관계 : 개체들 간의 관계
     - 구조 : 정보 흐름을 묘사하기 위한 것
   - REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기
 - PSL/PSA
   - 미시간 대학에서 개발, PSL과 PSA를 사용하는 자동화 도구
   - PSL(Problem Statement Language) : 문제(요구사항) 기술 언어
   - PSA(Problem Statement Analyzer) : PSL로 기술한 요구사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기
 - TAGS(Technology for Automated Generation of Systems)
   - 시스템 공학 방법 응용에 대한 자동 접근 방법, 개발 주기의 전 과정에 이용 할 수 있는 통합 자동화 도구
   - 구성 : IORL, 요구사항 분석과 IORL 처리를 위한 도구, 기초적인 TAGS 방법론
   - IORL : 요구사항 명세 언어

### HIPO(Hierarchy Input Process Output)
 - 시스템의 분석 및 설계나 문서화할 때 사용되는 기법, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타냄
 - 기본 모델은 입력, 처리, 출력으로 구성, 하향식 소프트웨어 개발을 위한 문서화 도구
 - 체계적 문서 관리 가능
 - 기호, 도표 등 사용 > 보기 쉽고 이해 쉬움
 - 기능과 자료의 의존 관계를 동시에 표현 가능
 - 변경, 유지보수 쉬움
 - HIPO Chart : 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것
 - HIPO Chart의 종류
   - 가시적 도표(도식 목차) : 전체적인 기능과 흐름, 계층 구조도
   - 총체적 도표(총괄도표, 개요 도표) : 전반적인 입력, 처리, 출력에 대한 정보를 제공하는 도표
   - 세부적 도표(상세 도표) : 총체적 도표에 포시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

<br>
<br>
<br>

## UML(Unified Modeling Language)
-----------------
### UML(Unified Modeling Language)의 개요
 - 개발자와 고객, 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
 - 객체지향 방법론의 장점 통합, 국제표준화기구인 OMG(Object Management Group)에서 표준으로 지정
 - 시스템의 구조를 표현하는 6개의 구조 다이어그램과 동작을 표현하는 7개의 행위 다이어그램을 표현할 수 있음
 - 각 다이어그램은 사물 간의 관계를 용도에 맞게 표현
 - 구성 요소 : 사물(Things), 관계(Relationships), 다이어그램(Diagram) 등

### 사물(Things)
 - 모델을 구성하는 가장 중요한 기본 요소
 - 종류
   - 구조 사물 : 시스템의 개념, 물리적 요소를 표현 / 클래스, 유스캐이스, 컴포넌트, 노드 등
   - 행동 사물 : 시간과 공간에 따른 요소들의 행위를 표현 / 상호작용, 상태 머신 등
   - 그룹 사물 : 요소들을 그룹으로 묶어서 표현 / 패키지
   - 주해 사물 : 부가적인 설명이나 제약 조건 등을 표현 / 노트

### 관계(Relationships)
 - 사물과 사물 사이의 연관성을 표현하는 것
 - 종류
   - 연관 관계(Association)
     - 실선으로 표현, 방향성은 화살표로
     - 양방향 관계의 경우 화살표 생략, 실선만으로 표기
     - 연관에 참여하는 객체의 개수를 의미하는 다중도(Multiplicity)를 선 위에 표기
       - "n" : n개의 객체 연관
       - "0..1" : 연관된 객체가 없거나 1개만 존재
       - "0..*" : 연관된 객체가 없거나 다수일 수 있음
       - "1..*" : 연관된 객체가 적어도 1개 이상
       - "n..m" : 연관된 객체가 n개 이상 m개 이하
       - P.54 다중도 표기법 예시 확인
   - 집합 관계(Aggregation)
     - 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현
     - 포함하는 쪽과 포함되는 쪽은 서로 독립적
     - 포함하는 쪽으로 속이 빈 마름모 연결하여 표현
   - 포함 관계(Composition)
     - 집합 관계 중 특수한 형태, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계(문,키 관계는 문이 없으면 키도 필요 없어짐)
     - 포함하는 쪽과 포함되는 쪽은 서로 독립될 수 없고 생명주기를 함께함
     - 포함하는 쪽으로 속이 채워진 마름모 연결하여 표현
   - 일반화 관계(Generalization)
     - 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현
     - 일반적인 개념을 상위, 구체적 개념을 하위라고 부름
     - 구체적 사물에서 일반적 사물 쪽으로 속이 빈 화살표로 표현
   - 의존 관계(Dependency)
     - 사물 간 연관은 있으나 필요에 의해 서로에게 영향을 주는, 짧은 시간 동안만 연관을 유지하는 관계(등급이 높으면 할인율 적용, 등급이 낮으면 할인율 미적용)
     - 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계
     - 영향을 주는 사물(등급)이 영향을 받는 사물(할인율) 쪽으로 점선 화살표를 연결하여 표현
   - 실체화 관계(Realization)
     - 사물이 할 수 있거나 해야 하는 기능(오퍼레이션, 인터페이스)으로 서로를 그룹화 할 수 있는 관계('비행기'와 '새'는 모두 '날 수 있'으므로 그룹화 가능)
     - 사물에서 기능쪽으로 속이 빈 점선 화살표 연결하여 표현

### 다이어그램(Diagram)
 - 사물과 관계를 도형으로 표현한 것
 - 여러 관점에서 시스템을 가시화한 view를 제공, 의사소통에 도움을 줌
 - 정적 모델링 - 구조적 다이어그램 / 동적 모델링 - 행위 다이어그램 사용
 - 구조적 다이어그램
   - 클래스 다이어그램
   - 객체 다이어그램
   - 컴포넌트 다이어그램
   - 배치 다이어그램
   - 복합체 구조 다이어그램
   - 패키지 다이어그램
 - 행위 다이어그램
   - 유스케이스 다이어그램
   - 순차 다이어그램
   - 커뮤니케이션 다이어그램
   - 상태 다이어그램
   - 활동 다이어그램
   - 상호작용 개요 다이어그램
   - 타이밍 다이어그램

### 스테레오 타입(Stereotype)
 - UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용
 - 길러멧(Guilemet)이라 부르는 겹화살괄호<<>> 사이에 표현할 형태를 기술
 - 주로 표현되는 형태
   - <<`include`>>
   - <<`extend`>>
   - <<`interface`>>
   - <<`exception`>>
   - <<`constructor`>>

<br>
<br>
<br>

## 주요 UML 다이어그램
-----------------
### 유스 케이스(Use Case) 다이어그램
 - 개발될 시스템과 관련된 외부 요소들을 사용자의 관점에서 표현한 것
 - 외부 요소 - 시스템 간의 상호 작용 확인 가능
 - 사용자의 요구사항을 분석하기 위한 도구로 사용
 - 시스템의 범위 파악 가능
 - 구성 요소
   - 시스템/시스템 범위 : 시스템 내부에서 수행되는 기능을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위 표현
   - 액터 : 시스템가 상호작용을 하는 모든 외부 요소
     - 주 액터 : 시스템을 사용함으로써 이득을 얻는 대상, 주로 사람
     - 부 액터 : 주 액터의 몰적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템, 주로 조직이나 기관
   - 유스케이스 : 사용자의 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것
   - 관계 : 액터와 유스케이스, 유스케이스와 유스케이스 사이의 연관, 포함, 확장, 일반화 관계 표현 가능
     - 포함(include) 관계 : 
       - 두 개 이상의 유스케이스에서 공통으로 적용되는 기능을 별도로 분리하여 새로운 유스케이스로 만들 경우 원래의 유스케이스와 새로운 유스케이스의 관계
       - 원래의 유스케이스에서 새로운 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 <<`include`>> 라고 표기
     - 확장(Extend) 관계 : 
       - 유스케이스가 특정 조건에 부합되어 기능이 확장 될 때 원래의 유스케이스와 확장된 유스케이스의 관계
       - 확장된 유스케이스에서 원래의 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 <<`extends`>> 라고 표기

### 클래스(Class) 다이어그램
 - 시스템을 구성하는 클래스, 클래스의 특성인 오퍼레이션, 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 표현한 것
 - 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
 - 시스템 구성 요소를 문서화 하는 데 사용
 - 코딩에 필요한 객체의 속성, 함수 등의 정보를 잘 표현하고 있어 시스템을 모델링하는 데 자주 사용
 - 구성 요소
   - 클래스 
     - 각 개체들이 갖는 속성과 오퍼레이션(동작)을 표현함
     - 일반적으로 3개 구획으로 나눔(이름, 속성, 오퍼레이션)
     - 속성(Attribute) : 클래스의 상태나 정보를 표현
     - 오퍼레이션(operation) : 클래스가 수행할 수 있는 동작, 함수(Method)라고도 함
   - 제약조건
     - 속성 값에 대한 제약 조건이나 오퍼레이션 수행 전 후에 지정해야 할 조건
   - 관계
     - 클래스 간의 연관성을 표현
     - 클래스 다이어그램에 표현하는 관계는 연관, 집합, 포함, 일반화, 의존 관계가 있음

### 접근제어자
 - 속성과 오퍼레이션에 동일하게 적용
 - 표현법
   - public : '+' / 어떤 클래스에서라도 접근이 가능
   - private : '-' / 해당 클래스 내부에서만 접근이 가능
   - protected : '#' / 동일 패키지 내의 클래스 혹은 해당 클래스를 상속 받은 외부 패키지의 클래스에서 접근 가능
   - package : '~' / 동일 패키지 내부에 있는 클래스에서만 접근 가능

### 순차(Sequence) 다이어그램
 - 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객체, 메시지 등의 요소를 사용하여 그림으로 표현한 것
 - 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현함
 - 동작에 참여하는 시스템이나 객체들의 수행 시간을 확인할 수 있다
 - 클래스 내부의 객체들을 기본 단위로 함, 그들의 상호 작용 표현
 - 주로 기능 모델링에서 작성한 유스케이스 명세서를 하나의 표현 범위로 하지만, 하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 함
 - 구성 요소
   - 액터(Actor) : 시스템으로부터 서비스를 요청하는 외부 요소, 사람이나 외부 시스템을 의미
   - 객체(Object) : 메시지를 주고받는 주체
   - 생명선(Lifeline) : 객체가 메모리에 존재하는 기간, 객체 아래쪽에 점선으로 표현
   - 실행 상자(Active Box) : 객체가 메시지를 주고받으며 구동되고 있음을 표현
   - 메시지(Message) : 객체가 상호 작용을 위해 주고받는 메시지