# 애플리케이션 설계
## 소프트웨어 아키텍쳐
-------------------
### 소프트웨어 아키텍쳐의 설계
 - 소프트웨어 아키텍쳐 : 소프트웨어의 골격이 되는 기본 구조, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
 - 소프트웨어 개발 시 적용되는 원칙과 지침, 이해 관계자들의 의사소통 도구로 활용
 - 소프트웨어 아키텍쳐의 설계는 기본적으로 좋은 품질을 유지하면서 사용자의 비 기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
 - 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
 - 기본원리 : 모듈화, 추상화, 단계적 분해, 정보은닉

### 상위설계 vs 하위설계
||상위 설계|하위 설계|
|---|---|---|
|별칭|아키텍쳐 설계, 예비 설계|모듈 설계, 상세 설계|
|설계 대상|시스템의 전체적인 구조|시스템의 내부 구조 및 행위|
|세부 목록|구조, DB, 인터페이스|컴포넌트, 자료 구조, 알고리즘|

### 모듈화(Modularity)
 - 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
   - 모듈 : 모듈화를 통해 분리된 시스템의 각 기능
 - 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성 향상
 - 모듈의 크기가 너무 작으면 개수가 많아져 모듈 통합에 비용이 많이 들고 너무 크게 나누면 비용은 적게 들지만 모듈 하나의 개발 비용이 커짐
 - 기능의 분리가 가능하여 인터페이스가 단순해짐
 - 프로그램의 효율적 관리가 가능하고 오류의 파급 효과를 최소화 할 수 있음

### 추상화(Abstraction)
 - 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것
 - 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법, 완전한 시스템 구축 전에 유사한 모델을 만들어 여러 요인 테스트
 - 최소의 비용으로 실제 상황에 대처 가능, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해줌
 - 추상화의 유형
   - 과정 추상화 : 자세한 수행 과정 X, 전반적인 흐름만 파악할 수 있게 설계하는 방법
   - 데이터 추상화 : 세부적 속성이나 용도 정의 X, 데이터 구조를 대표할 수 있는 표현으로 대체
   - 제어 추상화 : 이벤트 발생의 정확한 절차나 방법 정의 X, 대표할 수 있는 표현으로 대체

### 단계적 분해(Stepwise Refinement)
 - Niklaus Wirth에 의해 제안된 하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
 - 추상화의 반복에 의해 세분화됨
 - 소프트웨어 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 뒤로 미루어 진행
 - 건축을 예로 들면, 골조 설계 후 건물 내 층과 각 방의 경계를 정하고, 방들의 인테리어를 구상하는 것과 같이 대략적 > 세부적 설계

### 정보 은닉(Information Hiding)
 - 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
 - 정보 은닉된 모듈과 커뮤니케이션 시, 필요한 정보만 인터페이스를 통해 주고받음
 - 정보 은닉을 통해 모듈의 독립적 수행 가능, 하나의 모듈이 변경되더라도 다른 모듈에 영향 X, 수정이나 시험, 유지보수가 용이
 - 캡슐로 된 감기약을 예로 들면, 정보 은닉은 감기약 캡슐에 어떤 재료가 들어있는지는 모르지만 감기 걸렸을 때 먹는 약이라는 것만 알고 복용하는 것과 같은 의미

### 소프트웨어 아키텍쳐의 품질 속성
 - 소프트웨어 아키텍쳐가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템 측면, 비즈니스 측면, 아키텍쳐 측면으로 구분하여 구체화 시켜 놓은 것
 - 시스템 측면 : 기능
   - 성능
   - 보안
   - 가용성
   - 기능성
   - 사용성
   - 변경 용이성
   - 확장성
   - 기타 속성
 - 비즈니스 측면 : 경제성
   - 시장 적시성
   - 비용과 혜택
   - 예상 시스템 수명
   - 기타 속성
 - 아키텍쳐 측면 : 전체적인 구조
   - 개념적 무결성
   - 정확성, 완결성
   - 구축 가능성
   - 기타 속성

### 소프트웨어 아키텍쳐의 설계 과정
 1. 설계 목표 설정 : 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
 2. 시스템 타입 설정 : 시스템과 서브시스템 타입 결정, 설계 목표와 함께 고려하여 아키텍쳐 패턴 선택
 3. 아키텍쳐 패턴 적용 : 시스템의 표준 아키텍쳐 설계
 4. 서브시스템 구체화 : 서브시스템의 기능 및 상호작용을 위한 동작과 인터페이스 정의
 5. 검토 : 설계 목표에 부합하는지, 요구사항 반영은 잘 되었는지, 설계의 기본원리는 만족하는지 등을 검토

### 시스템 타입 / 협약에 의한 설계
 - 시스템 타입
   - 대화형 시스템 : 사용자 요구 발생 시 시스템이 이를 반응, 처리하는 시스템
   - 이벤트 중심 시스템 : 외부의 상태 변화에 따라 동작하는 시스템
   - 변환형 시스템 : 데이터 입력 시 정해진 작업을 수행하여 결과를 출력하는 시스템
   - 객체 영속성 시스템 : 데이터베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템
 - 협약(Contract)에 의한 설계
   - 컴포넌트 설계 시 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
   - 명세에 포함되는 조건
     - 선행 조건(Precondition) : 오퍼레이션 호출 전에 참이 되어야 할 조건
     - 결과 조건(Postcondition) : 오퍼레이션 수행 후 만족되어야 할 조건
     - 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

<br>
<br>
<br>

## 아키텍쳐 패턴
-----------------
### 아키텍쳐 패턴(pattern)의 개요
 - 아키텍쳐를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
 - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
 - 아키텍쳐 패턴에는 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있음
 - 아키텍쳐 스타일, 표준 아키텍쳐 라고도 함
 - 장점
   - 시행착오 줄임, 개발 시간 단축, 고품질 소프트웨어 생산 가능
   - 검증된 구조로 개발 > 안정적 개발 가능
   - 공통된 아키텍쳐 공유 > 의사소통이 간편
   - 구조 이해가 쉬움 > 손쉽게 유지 보수 가능
   - 개발 전에 시스템 특성 예측 가능
 - 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 등이 있음

### 레이어 패턴(Layer pattern)
 - 시스템을 계층으로 구분하여 구성하는 고전적인 방법
 - 각 서브시스템들이 계층 구조를 이룸, 하위 계층은 상위 계층에 대한 서비스 제공자가 되고 상위 계층은 하위 계층의 클라이언트가 된다
 - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어짐 > 변경 작업이 용이
 - 특정 계층만을 교체해 시스템을 개선하는 것이 가능
 - ex. OSI 참조 모델

### 클라이언트-서버 패턴(Client-Server pattern)
 - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
 - 사용자는 클라이언트와만 의사소통을 함, 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스 제공
 - 서버는 항상 대기상태 유지
 - 서버와 클라이언트는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적

### 파이프-필터 패턴(Pipe-Filter pattern)
 - 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
 - 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이함
 - 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능함
 - 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용
 - 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드가 발생함
   - 오버헤드 : 목표 달성을 위해 간접적 혹은 추가적으로 요구되는 시간, 메모리, 대역폭 등의 자원
 - ex. UNIX의 쉘(shell)

### 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
 - 서브시스템을 3개의 부분으로 구조화하는 패턴
 - 모델 : 서브시스템의 핵심 기능과 데이터를 보관
 - 뷰 : 사용자에게 정보를 표시
 - 컨트롤러 : 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄
 - 각 부분이 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있음
 - 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합함

### 기타 패턴
 - 마스터-슬레이브 패턴(Master-Slave Pattern)
   - 마스터 컴포넌트에서 동일한 구조의 슬레이브 컴포넌트로 작업을 분할한 후 처리된 결과물을 다시 돌려받는 방식으로 작업 수행
   - 마스터 컴포넌트는 모든 작업의 주체, 슬레이브 컴포넌트는 지시에 따라 작업을 수행하여 결과 반환
   - 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 사용
     - 장애 허용 시스템 : 일부가 결함 또는 고장으로 기능이 정지되더라도 전체 시스템은 정상적으로 수행이 가능한 시스템
 - 브로커 패턴(Broker Pattern)
   - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에게 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해줌
   - 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴
   - 분산 환경 시스템에서 주로 활용
 - 피어 투 피어 패턴(Peer-To-Peer Pattern)
   - 피어(Peer)를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하는 클라이언트가 될 수도 있고 서비스를 제공하는 서버가 될 수도 있음
   - 멀티 스레딩(프로세스를 두 개 이상의 실행 단위로 구분하여 자원을 공유하며 병렬로 수행하는 기능)방식을 사용
 - 이벤트-버스 패턴(Event-Bus Pattern)
   - 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
   - 4개의 주요 컴포넌트로 구성
     - 이벤트를 생성하는 소스
     - 이벤트를 수행하는 리스너
     - 이벤트의 통로인 채널
     - 채널들을 관리하는 버스
 - 블랙보드 패턴(Blackboard Pattern)
   - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있음
   - 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
   - 음석인식, 차량식별, 신호해석 등에 주로 활용
 - 인터프리터 패턴(Interpreter Pattren)
   - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성
   - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용

<br>
<br>
<br>

## 객체지향(Object-Oriented)
-----------------
### 객체지향의 개요
 - 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 객체들을 조립하여 작성할 수 있는 기법
 - 구조적 기법의 문제점에 대한 해결책으로 채택
 - 소프트웨어의 재사용 및 확장이 용이, 고품질의 소프트웨어를 빠르개 개발할 수 있고 유지보수가 쉬움
 - 