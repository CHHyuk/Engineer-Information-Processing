# 애플리케이션 설계
## 소프트웨어 아키텍쳐
-------------------
### 소프트웨어 아키텍쳐의 설계
 - 소프트웨어 아키텍쳐 : 소프트웨어의 골격이 되는 기본 구조, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
 - 소프트웨어 개발 시 적용되는 원칙과 지침, 이해 관계자들의 의사소통 도구로 활용
 - 소프트웨어 아키텍쳐의 설계는 기본적으로 좋은 품질을 유지하면서 사용자의 비 기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
 - 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
 - 기본원리 : 모듈화, 추상화, 단계적 분해, 정보은닉

### 상위설계 vs 하위설계
||상위 설계|하위 설계|
|---|---|---|
|별칭|아키텍쳐 설계, 예비 설계|모듈 설계, 상세 설계|
|설계 대상|시스템의 전체적인 구조|시스템의 내부 구조 및 행위|
|세부 목록|구조, DB, 인터페이스|컴포넌트, 자료 구조, 알고리즘|

### 모듈화(Modularity)
 - 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
   - 모듈 : 모듈화를 통해 분리된 시스템의 각 기능
 - 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성 향상
 - 모듈의 크기가 너무 작으면 개수가 많아져 모듈 통합에 비용이 많이 들고 너무 크게 나누면 비용은 적게 들지만 모듈 하나의 개발 비용이 커짐
 - 기능의 분리가 가능하여 인터페이스가 단순해짐
 - 프로그램의 효율적 관리가 가능하고 오류의 파급 효과를 최소화 할 수 있음

### 추상화(Abstraction)
 - 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것
 - 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법, 완전한 시스템 구축 전에 유사한 모델을 만들어 여러 요인 테스트
 - 최소의 비용으로 실제 상황에 대처 가능, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해줌
 - 추상화의 유형
   - 과정 추상화 : 자세한 수행 과정 X, 전반적인 흐름만 파악할 수 있게 설계하는 방법
   - 데이터 추상화 : 세부적 속성이나 용도 정의 X, 데이터 구조를 대표할 수 있는 표현으로 대체
   - 제어 추상화 : 이벤트 발생의 정확한 절차나 방법 정의 X, 대표할 수 있는 표현으로 대체

### 단계적 분해(Stepwise Refinement)
 - Niklaus Wirth에 의해 제안된 하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
 - 추상화의 반복에 의해 세분화됨
 - 소프트웨어 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 뒤로 미루어 진행
 - 건축을 예로 들면, 골조 설계 후 건물 내 층과 각 방의 경계를 정하고, 방들의 인테리어를 구상하는 것과 같이 대략적 > 세부적 설계

### 정보 은닉(Information Hiding)
 - 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
 - 정보 은닉된 모듈과 커뮤니케이션 시, 필요한 정보만 인터페이스를 통해 주고받음
 - 정보 은닉을 통해 모듈의 독립적 수행 가능, 하나의 모듈이 변경되더라도 다른 모듈에 영향 X, 수정이나 시험, 유지보수가 용이
 - 캡슐로 된 감기약을 예로 들면, 정보 은닉은 감기약 캡슐에 어떤 재료가 들어있는지는 모르지만 감기 걸렸을 때 먹는 약이라는 것만 알고 복용하는 것과 같은 의미

### 소프트웨어 아키텍쳐의 품질 속성
 - 소프트웨어 아키텍쳐가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템 측면, 비즈니스 측면, 아키텍쳐 측면으로 구분하여 구체화 시켜 놓은 것
 - 시스템 측면 : 기능
   - 성능
   - 보안
   - 가용성
   - 기능성
   - 사용성
   - 변경 용이성
   - 확장성
   - 기타 속성
 - 비즈니스 측면 : 경제성
   - 시장 적시성
   - 비용과 혜택
   - 예상 시스템 수명
   - 기타 속성
 - 아키텍쳐 측면 : 전체적인 구조
   - 개념적 무결성
   - 정확성, 완결성
   - 구축 가능성
   - 기타 속성

### 소프트웨어 아키텍쳐의 설계 과정
 1. 설계 목표 설정 : 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
 2. 시스템 타입 설정 : 시스템과 서브시스템 타입 결정, 설계 목표와 함께 고려하여 아키텍쳐 패턴 선택
 3. 아키텍쳐 패턴 적용 : 시스템의 표준 아키텍쳐 설계
 4. 서브시스템 구체화 : 서브시스템의 기능 및 상호작용을 위한 동작과 인터페이스 정의
 5. 검토 : 설계 목표에 부합하는지, 요구사항 반영은 잘 되었는지, 설계의 기본원리는 만족하는지 등을 검토

### 시스템 타입 / 협약에 의한 설계
 - 시스템 타입
   - 대화형 시스템 : 사용자 요구 발생 시 시스템이 이를 반응, 처리하는 시스템
   - 이벤트 중심 시스템 : 외부의 상태 변화에 따라 동작하는 시스템
   - 변환형 시스템 : 데이터 입력 시 정해진 작업을 수행하여 결과를 출력하는 시스템
   - 객체 영속성 시스템 : 데이터베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템
 - 협약(Contract)에 의한 설계
   - 컴포넌트 설계 시 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
   - 명세에 포함되는 조건
     - 선행 조건(Precondition) : 오퍼레이션 호출 전에 참이 되어야 할 조건
     - 결과 조건(Postcondition) : 오퍼레이션 수행 후 만족되어야 할 조건
     - 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

<br>
<br>
<br>

## 아키텍쳐 패턴
-----------------
### 아키텍쳐 패턴(pattern)의 개요
 - 아키텍쳐를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
 - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
 - 아키텍쳐 패턴에는 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있음
 - 아키텍쳐 스타일, 표준 아키텍쳐 라고도 함
 - 장점
   - 시행착오 줄임, 개발 시간 단축, 고품질 소프트웨어 생산 가능
   - 검증된 구조로 개발 > 안정적 개발 가능
   - 공통된 아키텍쳐 공유 > 의사소통이 간편
   - 구조 이해가 쉬움 > 손쉽게 유지 보수 가능
   - 개발 전에 시스템 특성 예측 가능
 - 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 등이 있음

### 레이어 패턴(Layer pattern)
 - 시스템을 계층으로 구분하여 구성하는 고전적인 방법
 - 각 서브시스템들이 계층 구조를 이룸, 하위 계층은 상위 계층에 대한 서비스 제공자가 되고 상위 계층은 하위 계층의 클라이언트가 된다
 - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어짐 > 변경 작업이 용이
 - 특정 계층만을 교체해 시스템을 개선하는 것이 가능
 - ex. OSI 참조 모델

### 클라이언트-서버 패턴(Client-Server pattern)
 - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
 - 사용자는 클라이언트와만 의사소통을 함, 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스 제공
 - 서버는 항상 대기상태 유지
 - 서버와 클라이언트는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적

### 파이프-필터 패턴(Pipe-Filter pattern)
 - 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
 - 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이함
 - 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능함
 - 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용
 - 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드가 발생함
   - 오버헤드 : 목표 달성을 위해 간접적 혹은 추가적으로 요구되는 시간, 메모리, 대역폭 등의 자원
 - ex. UNIX의 쉘(shell)

### 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
 - 서브시스템을 3개의 부분으로 구조화하는 패턴
 - 모델 : 서브시스템의 핵심 기능과 데이터를 보관
 - 뷰 : 사용자에게 정보를 표시
 - 컨트롤러 : 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄
 - 각 부분이 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있음
 - 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합함

### 기타 패턴
 - 마스터-슬레이브 패턴(Master-Slave Pattern)
   - 마스터 컴포넌트에서 동일한 구조의 슬레이브 컴포넌트로 작업을 분할한 후 처리된 결과물을 다시 돌려받는 방식으로 작업 수행
   - 마스터 컴포넌트는 모든 작업의 주체, 슬레이브 컴포넌트는 지시에 따라 작업을 수행하여 결과 반환
   - 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 사용
     - 장애 허용 시스템 : 일부가 결함 또는 고장으로 기능이 정지되더라도 전체 시스템은 정상적으로 수행이 가능한 시스템
 - 브로커 패턴(Broker Pattern)
   - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에게 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해줌
   - 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴
   - 분산 환경 시스템에서 주로 활용
 - 피어 투 피어 패턴(Peer-To-Peer Pattern)
   - 피어(Peer)를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하는 클라이언트가 될 수도 있고 서비스를 제공하는 서버가 될 수도 있음
   - 멀티 스레딩(프로세스를 두 개 이상의 실행 단위로 구분하여 자원을 공유하며 병렬로 수행하는 기능)방식을 사용
 - 이벤트-버스 패턴(Event-Bus Pattern)
   - 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
   - 4개의 주요 컴포넌트로 구성
     - 이벤트를 생성하는 소스
     - 이벤트를 수행하는 리스너
     - 이벤트의 통로인 채널
     - 채널들을 관리하는 버스
 - 블랙보드 패턴(Blackboard Pattern)
   - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있음
   - 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
   - 음석인식, 차량식별, 신호해석 등에 주로 활용
 - 인터프리터 패턴(Interpreter Pattren)
   - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성
   - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용

<br>
<br>
<br>

## 객체지향(Object-Oriented)
-----------------
### 객체지향의 개요
 - 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 객체들을 조립하여 작성할 수 있는 기법
 - 구조적 기법의 문제점에 대한 해결책으로 채택
 - 소프트웨어의 재사용 및 확장이 용이, 고품질의 소프트웨어를 빠르개 개발할 수 있고 유지보수가 쉬움
 - 복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리를 지원
 - 현실 세계를 모형화하므로 사용자와 개발자가 이해하기 쉬움
 - 주요 구성 요소 및 개념
   - 객체
   - 클래스
   - 캡슐화
   - 상속
   - 다형성
   - 연관성

### 객체(Object)
 - 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈
   - 데이터 : 객체가 가지고 있는 정보, 속성이나 상태, 분류 등을 나타냄, 속성, 상태, 변수, 상수, 자료 구조라고도 함
   - 함수 : 객체가 수행하는 기능, 객체의 데이터를 처리하는 알고리즘, 메소드, 서비스, 동작, 연산이라고도 함
 - 객체의 특성
   - 독립적으로 식별 가능한 이름을 가지고 있다.
   - 객체가 가질 수 있는 조건을 상태(State)라고 함, 일반적으로 상태는 시간에 따라 변함
   - 객체 간 상호 연관성에 의한 관계가 형성됨
   - 객체가 반응할 수 있는 메시지의 집합을 행위 라고 함, 객체는 행위의 특징을 나타낼 수 있다
   - 객체는 일정한 기억장소를 가지고 있다
 - 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행함

### 클래스(Class)
 - 공통된 속성과 연산(행위)을 갖는 객체의 집합
 - 각 객체들이 갖는 속성과 연산을 정의하고 있는 틀
 - 객체지향 프로그램에서 데이터를 추상화하는 단위
 - 클래스에 속한 각 객체를 인스턴스(Instance)라고 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함
 - 동일 클래스의 각각의 인스턴스들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라 동일 기능을 하는 여러 가지 객체를 나타냄
 - 최상위 클래스는 상위 클래스를 갖지 않는 클래스
 - 슈퍼 클래스는 특정 클래스의 상위 클래스이고 서브 클래스는 특정 클래스의 하위 클래스다

### 캡슐화(Encapsulation)
 - 데이터와 함수를 하나로 묶는 것을 의미
 - 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적, 외부 묘듈의 변경으로 인한 파급 효과가 적음
 - 재사용이 용이함
 - 객체 간 메시지 주고받을 때 상대 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해지고 객체 간의 결합도가 낮아짐

### 상속(Inheritance)
 - 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
 - 상위 클래스의 모든 속성과 연산을 자신의 클래스에서 다시 정의하지 않고도 즉시 사용 가능
 - 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용 가능
 - 객체와 클래스의 재사용, 즉 소프트웨어의 재사용을 높이는 중요한 개념
 - 다중상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것

### 다형성(Polymorphism)
 - 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력
 - 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함
 - 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것
 - ex. '+' 연산자는 숫자클래스에서 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용

### 연관성(Relationship)
 - 두 개 이상의 객체들이 상호 참조하는 관계
 - 종류
   - 연관화 : 2개 이상의 객체가 상호 관련 되어있음
   - 분류화 : 동일한 형의 특성을 갖는 객체들을 모아 구성
   - 집단화 : 관련있는 객체들을 묶어 하나의 상위 객체 구성
   - 일반화 : 공통적인 성질들로 추상화한 상위 객체를 구성
   - 특수화/상세화 : 상위 객체를 구체화하여 하위 객체를 구성

<br>
<br>
<br>

## 객체지향 분석 및 설계
-----------------
### 객체지향 분석의 개념
 - 객체지향 분석(OOA : Object Oriented Analysis) : 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 객체, 이와 관련된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업
 - 소프트웨어 개발을 위한 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어 분석
 - 분석가에게 중요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화할 수 있게 해줌
 - 객체는 클래스로부터 인스턴스화되고, 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적

### 객체지향 분석의 방법론
 - Rumbaugh(럼바우) 방법 : 가장 일반적, 분석 활동을 객체모델, 동적모델, 기능모델로 나누어 수행
 - Booch(부치) 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법
 - Jacobson 방법 : 유스 케이스를 강조하여 사용하는 분석 방법
 - Coad와 Yourdon 방법 : E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
 - Wirfs-Brock 방법 : 분석과 설계 간 구분이 없고, 고객 명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법

### 럼바우 분석 기법
 - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법, 객체 모델링 이라고도 함
 - 객체모델링 > 동적모델링 > 기능모델링 순으로 이루어짐
   - 객체모델링(정보모델링) : 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
   - 동적모델링 : 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들의 제어흐름, 상호작용, 동작순서 등의 동적인 행위를 표현하는 모델링
   - 기능모델링 : 자료흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 객체지향 설계 원칙(SOLID)
 - 단일 책임 원칙 : 객체는 단 하나의 책임만 가져야 함, 응집도는 높게, 결합도는 낮게 설계
 - 개방-폐쇄 원칙 : 기존 코드 변경 없이 기능 추가 가능하도록 설계, 캡슐화
 - 리스코프 치환 원칙 : 자식은 최소한 부모 클래스에서 가능한 행위는 수행 할 수 있어야 한다는 설계 원칙, 자식은 부모의 것을 재정의, 무시하지 않고 확장만 수행토록 함
 - 인터페이스 분리 원칙 : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
 - 의존 역전 원칙 : 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

<br>
<br>
<br>

## 모듈
-----------------
### 모듈(Module)의 개요
 - 모듈화를 통해 분리된 시스템의 각 기능
 - 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용
 - 단독 컴파일 가능, 재사용 할 수 있음
 - 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어짐
 - 독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈에 영향을 거의 주지 않음, 오류가 발생해도 쉽게 발견, 해결 가능
 - 모듈의 독립성은 결합도와 응집도에 의해 측정, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함

### 결합도(Coupling)
 - 모듈 간의 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
 - 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음
 - 결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움
 - 자료 결합도, 스탬프 결합도, 제어 결합도, 외부 결합도, 공통 결합도, 내용 결합도 순으로 결합도가 강해짐
 - 자료 결합도
   - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
   - 어떤 모듈이 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고 호출받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 방식
   - 모듈 간의 내용을 전혀 알 필요가 없는 상태로서 한 모듈의 내용을 변경하더라도 다른 모듈에 전혀 영향을 주지 않는 가장 바람직한 결합도
 - 스탬프(검인) 결합도
   - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
   - 두 모듈의 동일한 자료 구조를 조회하는 경우의 결합도이며, 자료 구조의 어떠한 변화, 즉 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않은 모듈에까지 영향을 줌
 - 제어 결합도
   - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
   - 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생
   - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생하게 됨
 - 외부 결합도
   - 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
   - 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있음
 - 공통(공유) 결합도
   - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
   - 공통 데이터 영역의 내용을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 만듬
 - 내용 결합도
   - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
   - 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당

### 응집도(Cohesion)
 - 정보 은닉(한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하게 하는 기법)의 개념을 확장한 것
 - 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
 - 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음
 - 기능적 응집도, 순차적 응집도, 교환(통신)적 응집도, 절차적 응집도, 시간적 응집도, 논리적 응집도, 우연적 응집도 순으로 응집도가 약해짐
   - 기능적 응집도 : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
   - 순차적 응집도 : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
   - 교환(통신)적 응집도 : 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
   - 절차적 응집도 : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
   - 시간적 응집도 : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
   - 논리적 응집도 : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
   - 우연적 응집도 : 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

### 팬인(Fan-In) / 팬아웃(Fan-Out)
 - 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수
 - 팬아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수
 - 시스템의 복잡도 파악 가능
 - 팬인이 높다 : 재사용 측면에서 설계가 잘 되었다고 볼 수 있으나, 단일 장애점(구성요소가 동작하지 않으면 전체 시스템이 중단되어 버리는 요소, 단일 실패점)이 발생할 수 있음
 - 팬아웃이 높다 : 불필요하게 다른 모듈을 호출하고 있는지 검토, 단순화시킬 수 있는지 여부에 대한 검토 필요
 - 최적화 : 팬인은 높게, 팬아웃은 낮게

### N-S 차트
 - 논리의 기술에 중점을 둔 도형을 이용한 표현 방법, 박스 다이어그램, Chapin Chart 라고도 함
 - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현
 - GOTO나 화살표 사용 X
 - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
 - 선택과 반복 구조를 시각적으로 표현
 - 이해하기 쉽고 코드 변환이 용이함
 - 읽기 쉽지만 작성이 어렵고, 임의로 제어를 전이하는 것이 불가능
 - 총체적인 구조 표현과 인터페이스를 나타내기 어려움
 - 단일 입구와 단일 출구로 표현

<br>
<br>
<br>

## 공통 모듈
-----------------
### 공통 모듈의 개요
 - 여러 시스템에서 공통적으로 사용할 수 있는 모듈
 - 자주 사용되는 계산식이나 매번 필요한 사용자 인증 같은 기능 등
 - 모듈의 재사용성 확보와 중복 개발 회피를 위해 설계 과정에서 공통 부분을 식별하고 명세를 작성할 필요가 있음
 - 공통 모듈의 명세 기법
   - 정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
   - 명확성 : 중의적인 해석이 되지 않도록 명확히 작성
   - 완전성 : 구현을 위해 필요한 모든 것을 작성
   - 일관성 : 공통 기능들 간의 상호 충돌이 일어나지 않도록 작성
   - 추적성 : 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

### 재사용(Reuse)
 - 비용과 개발 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 방법
 - 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 함
 - 외부 모듈과의 결합도는 낮고, 응집도는 높아야 함
 - 규모에 따른 분류
   - 함수와 객체 : 클래스, 메소드 단위의 소스 코드를 재사용
   - 컴포넌트 : 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈, 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
   - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

### 효과적인 모듈 설계 방안
 - 결합도는 줄이고 응집도는 높여 모듈의 독립성과 재사용성 높임
 - 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지시킴
 - 복잡도와 중복성을 줄이고 일관성 유지
 - 기능의 예측이 가능해야 하며, 지나치게 제한적이면 안됨
 - 유지보수가 용이해야 함
 - 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해
 - 하나의 입구와 하나의 출구를 갖도록 해야 함
 - 인덱스 번호나 기능 코드들이 전반적인 처리 구조에 예기치 못한 영향을 끼치지 않도록 모듈 인터페이스를 설계해야 함
 - 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 함

<br>
<br>
<br>

## 코드
-----------------
### 코드(Code)의 개요
 - 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호
 - 정보를 신속, 정확, 명료하게 전달할 수 있어야 함
 - 일정한 규칙 준수, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미침
 - 일반적인 코드의 예 : 주민등록번호, 학번, 전화번호 등
 - 주요 기능
   - 식별 : 데이터 간의 성격에 따라 구분이 가능
   - 분류 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음
   - 배열 : 의미를 부여하여 나열할 수 있음
   - 표준화 : 다양한 데이터를 기준에 맞추어 표현 가능
   - 간소화 : 복잡한 데이터 간소화 가능

### 코드의 종류
 - 순차 코드 : 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법 ex. 1 2 3 4
 - 블록 코드 : 공통성이 있는 것 끼리 블록으로 구분, 각 블록 내에서 일련번호를 부여하는 방법 ex. 1001~1100 : 총무부, 1101~1200 : 영업부
 - 10진 코드 : 10진 분할 후 다시 그 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복하는 방법 ex. 1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프트웨어 설계
 - 그룹 분류 코드 : 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고 각 그룹 안에서 일련번호를 부여하는 방법 ex. 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계
 - 연상 코드 : 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방식 ex. TV-40 : 40인치 TV, L-15-220 : 15W 220V의 램프
 - 표의 숫자 코드 : 성질(길이,넓이,부피,지름,높이 등)의 물리적 수치를 그대로 코드에 적용시키는 방법 ex. 120-720-1500 : 두께, 폭, 길이가 120,720,1500인 강판
 - 합성 코드 : 두 개 이상의 코드를 조합하여 만드는 기법 ex. KE-711 : 대한항공 711기

### 코드 부여 체계
 - 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
 - 각 개체에 유일한 코드를 부여하여 개체들의 식별 및 추출을 용이하게 함
 - 코드 부여 전에 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함
 - 담당자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야 함

<br>
<br>
<br>

## 디자인 패턴
-----------------
### 디자인 패턴의 개요
 - 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 잠초할 수 있는 전형적인 해결 방식 또는 예제
 - 문제 및 배경, 실제 적용 사례, 재사용 가능한 샘플 코드 등으로 구성
 - 개발 과정 중 문제 발생 시 새로운 해결책 구상보단 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
 - 디자인 패턴의 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있음
 - GoF 디자인 패턴
   - 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용할 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴
   - 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개, 총 23개 패턴으로 구성

### 아키텍쳐 패턴 vs 디자인 패턴
 - 공통점 : 소프트웨어 설계를 위한 참조 모델
 - 차이점
   - 아키텍쳐 패턴은 디자인 패턴보다 상위 수준의 설계에 사용
   - 아키텍쳐 패턴이 전체 시스템의 구조를 설계하기 위한 참조모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조모델
   - 몇몇 디자인 패턴은 특정 아키텍쳐 패턴을 구현하는데 유용하게 사용됨

### 디자인 패턴 사용의 장, 단점
 - 범용적인 코딩 스타일로 인해 구조 파악이 용이
 - 객체지향 설계 및 구현의 생산성을 높이는 데 적합
 - 검증된 구조의 재사용 > 개발 시간과 비용 절감
 - 초기 투자비용이 부담될 수 있음
 - 개발자 간 원활한 의사소통 가능
 - 설계 변경 요청에 대한 유연한 대처 가능
 - 객체지향 기반한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않음

### 생성 패턴
 - 객체의 생성과 관련된 패턴
 - 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해줌
 - 종류
   - 추상 팩토리
     - 구체적 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
     - 연관된 서브클래스를 묶어 한번에 교체 가능
     - 서로 다른 부품을 조립만 하는 조립공장
   - 빌더 
     - 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성
     - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음
     - 건축가가 블록을 조립하는 모습
   - 팩토리 메소드(가상 생성자 패턴)
     - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
     - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
     - 부품부터 완성품까지 통째로 찍어내는 공장
   - 프로토타입
     - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
     - 일반적인 방법으로 객체를 생성, 비용이 큰 경우 주로 이용
     - 원형을 두고 복제품을 만드는 것
   - 싱글톤
     - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수는 없다
     - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화
     - 식당에서 누구나 이용할 수 있지만 한번에 한 명만 이용 가능한 정수기

### 구조 패턴
 - 클래스